## I. 트랜잭션

### 트랜잭션의 개념

→ DBMS에서 데이터를 다루는 논리적인 작업의 단위

### 트랜잭션의 과정

- 트랜잭션의 작동 원리

데이터베이스에 저장된 테이블을 읽어와 주기억장치 버퍼에 저장 →

버퍼에 저장된 데이터를 수정 →

최종적으로 데이터베이스에 다시 저장

- COMMIT 문 : 트랜잭션의 종료를 알리는 SQL 문
- 트랜잭션의 수행 과정

시작(begin) → 수행 → 부분완료 → 버퍼내용 기록 → 완료(commit)

### 트랜잭션의 성질(ACID 성질)

- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 수행되지 않아야 함
- 일관성(Consistency) : 트랜잭션 수행 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
- 고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하면 X
- 지속성(Durability) : 수행을 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함

### 트랜잭션의 상태

트랜잭션은 수행이 완료되면 부분완료 혹은 실패 상태 중 하나가 됨

- 부분완료 : 트랜잭션 수행은 완료되었지만 변경 내용이 데이터베이스에 기록되었는지 확실하지 않은 상태
- 실패 : 트랜잭션을 중간에 중단했거나 부분완료 상태에서 변경 내용을 데이터베이스에 저장하지 못한 상태

### 트랜잭션과 DBMS

- DBMS는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원함
    - 원자성 유지를 위해 회복 관리자 프로그램 작동
    - 일관성 유지를 위해 무결성 제약조건, 동시성 제어 알고리즘을 활용
    - 고립성 유지를 위해 동시성 제어 알고리즘 작동
    - 지속성 유지를 위해 회복 관리자 프로그램 이용

## II. 동시성 제어

### 동시성 제어란?

→ 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

### 갱신손실 문제

→ 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생(데이터베이스에서 절대 발생하면 안 됨)

갱신손실 문제를 해결하는 방법으로 자신이 데이터를 수정 중이라는 사실을 알리는 방법인 락을 사용함

- 락 : 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치(자물쇠)
    - 공유락(LS, shared lock) : 트랜잭션이 읽기를 할 때 사용하는 락
    - 배타락(LX, exclusive  lock) : 읽기/쓰기를 할 때 사용하는 락
- 공유락과 배타락을 사용하는 규칙
    - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다
    - 다른 트랜잭션이 데이터에 LS(X)을 걸어두면, LS(X)의 요청은 허용하고 LX(X)는 허용하지 않음
    - 다른 트랜잭션이 데이터에 LX(X)을 걸어두면, LS(X)와 LX(X) 모두 허용하지 않음

![image](https://user-images.githubusercontent.com/104254012/213676541-29c1dadb-b7e2-4bd2-97a7-414f9f3dc3cf.png)
→ 트랜잭션의 공유락은 상호 허용 가능, but 배타락은 허용 X

- **2단계 락킹**

→ 락을 걸고 해제하는 시점에 제한을 두지 않으면 데이터에 락을 걸었다 푸는 중간 과정에 락의 해지 상태가 생기면서 다른 트랜잭션에게 중간 결과를 보일 수 있음

- 확장단계(Growing phase, Expanding phase) : 트랜잭션이 필요한 락을 획득하는 단계, 이미 획득한 락을 해제하지 않음
- 수축단계(Shrinking phase) : 트랜잭션이 락을 해제하는 단계, 새로운 락을 획득하지 않음
- **데드락deadlock**

→ 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대해 락을 획득하고 상대방 데이터에 대해 락을 요청하면 무한 대기 상태에 빠질 수 있음

## III. 트랜잭션 고립 수준

### 트랜잭션 동시 실행 문제

- 오손 읽기(dirty read)

→ 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제

- 반복불가능 읽기(non-repeatable read)

→  트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복되지 않는 현상

- 유령데이터 읽기(phantom read)

→ 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유렁 데이터)가 나타나는 현상

### 트랜잭션 고립 수준 명령어

- READ UNCOMMITTED(Level = 0)
    - 고립 수준 제일 낮음
    - 자신의 데이터에 아무런 공유락을 걸지 않음
    - 문제점 : 오손 읽기, 반복불가능 읽기, 유렁데이터 읽기
- READ COMMITTED(Level = 1)
    - 오손 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에 해지가능
    - 문제점 : 반복불가능 읽기, 유령데이터 읽기
- REPEATABLE READ(Level = 2)
    - 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 때까지 유지해 다른 트랜잭션이 자신의 데이터를 갱신할 수 없도록 함
    - 다른 고립화 수준에 비해 데이터의 동시성이 낮음
    - 문제점 : 유령데이터 읽기
- SERIALIZABLE(Level = 3)
    - 고립 수준이 가장 높음
    - 다른 사용자가 데이터를 변경하려고 할 때 트랜잭션을 완벽하게 분리할 수 있음
    - 제한이 가장 심하고 데이터의 동시성도 낮음
    - 문제점 : 없음

## IV. 회복

→ 회복(recovery) : 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능

### 데이터베이스 시스템 장애 유형

- 시스템 충돌
- 미디어 장애
- 응용 소프트웨어 오류
- 자연재해
- 부주의 혹은 태업(sabotage)

→ 회복에 중점을 두는 유형 : 시스템 충돌, 미디어 장애, 응용 소프트웨어 오류

### 트랜잭션과 회복

→ 트랜잭션은 데이터의 변경 내용을 한순간에 모두 기록하지 않음

→ DBMS의 회복 관리자(recovery manager)는 원자성과 지속성을 보장하여 장애로부터 데이터베이스를 보호함

### 로그 파일

→ 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 기록을 추적함

로그 파일에 저장된 로그의 구조 : <트랜잭션번호, 로그 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>

### 로그 파일을 이용한 회복

- 트랜잭션의 재실행(REDO) : 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정
- 트랜잭션의 취소(UNDO) : COMMIT 연산이 없을 때 트랜잭션이 한 일을 취소하는 과정에서 완료되지 못해도 버퍼의 변경 내용이 데이터베이스에 기록될 가능성이 크므로 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시키는 과정
- 즉시갱신(immediate update) : ‘버퍼 → 로그 파일’, ‘버퍼 → 데이터베이스’ 작업이 부분완료 전에 동시에 진행될 수 있음
- 지연갱신(deferred update) : ‘버퍼 → 로그 파일’이 모두 끝난 후 부분완료를 하고 ‘버퍼 → 데이터베이스’ 작업을 진행하는 방법
