# [3주차]*8장*트랜잭션, 동시성 제어, 회복\_박가현

# 트랜잭션

### 정의

- 데이터베이스에서 상태를 변화시키는 작업 단위
- 한번에 수행되어야 할 일련의 연산
- ex) 회원의 등급 업그레이드
- 이런 트랜잭션은 사람의 기준에 따라 정해지는데 잘 설계하는 것이 데이터를 다룰 때 많은 이점을 가져옴

### 동작 과정

- 트랜잭션은 데이터베이스에 저장된 테이블을 읽어와 주기억장치 버퍼에 저장하고 버퍼에 저장된 데이터를 수정한 후 최종적으로 데이터베이스에 다시 저장
  - ex) a계좌에서 만원을 인출하여 b계좌에 만원을 입금하는 트랜잭션이 있다고 가정하면
  1. a계좌 값을 주기억장치버퍼로 읽어온다
  2. b계좌 값을 주기억장치버퍼로 읽어온다
  3. a계좌에서 만원을 인출한 값을 저장
  4. b계좌에서 만원을 입금한 값을 저장
  5. a계좌의 값을 데이터베이스에 기록한다
  6. b계좌의 값을 데이터베이스에 기록한다
  - 그런데 실제 dbms는 4번까지만 수행을 하고 commit을 통해 완료했다고 알림 이는 사용자에게 빠른 응답성과 다른 트랜잭션의 수행을 위해서 ( 나머지 5, 6은 dbms가 책임지고 수행)

### 트랜잭션 성질

- 원자성(atomicity)
  하나의 트랜잭션이 더 작게 나눌 수 없는 최소의 단위라는 뜻으로 트랜잭션 안에 있는 작업이 전부 수행되거나 전부 수행되지 않아야 함.
  ex) 위의 예시처럼 만원을 인출하였지만 만원을 입금하지 않고 부분적으로만 수행한다면 큰 문제가 생겨남 - rollback
  트랜잭션을 전체 혹은 savepoint까지 무효화시킴 - savepoint
  수정내용을 반영하는 포인트( 저장점)
- 일관성(consistency
  테이블이 생성될 때 create 문과 alter문의 무결성 제약조건을 통해 명시된다 ( ex) not null…) 트랜잭션은 이 조건에 따라 일관성을 유지
  ex) 모든 계좌의 돈은 0원 이상이어야 한다. 라는 무결성 제약 조건이 있다면 이를 위반하는 트랜잭션은 모두 중단
- 고립성(isolation)
  트랜잭션이 수행되고 있을 때, 다른 트랜잭션의 연산작업이 중간에 끼어들어 기존 작업에 영향을 주지 못하도록 하는 것.
  ex) 계좌 이체 작업을 진행하고 있는 도중 계좌 잔액을 조회하는 트랜잭션 같은 건 동시에 수행될 수 없다
  ex) 동시에 작업이 수행되는 것의 문제점은 한 트랜잭션은 잔액이 5만원인 계좌에서 만원을 빼 4만원을 만들어 저장하였는데 동시에 다른 트랜잭션이 5만원인 계좌에서 만원을 더해 6만원을 저장하였다. 옳지 않은 금액이 저장됨

- 지속성(durability)
  트랜잭션을 성공한 후 데이터베이스에 반영되는 것은 영원히 반영되어야 한다는 것을 의미. 시스템에 문제가 발생하거나 종료되더라도 데이터베이스에 반영된 값은 그대로 유지 필요

<aside>
💡 dbms는 트랜잭션이 안정적으로 처리될 수 있도록 원자성 일관성 고립성 지속성을 유지하도록 지원한다 ( 회복관리자 프로그램, 무결성 제약조건, 동시성 제어)

</aside>
<br></br>

# 동시성 제어(concurrency control)

### 갱신 손실 문제(lost update)

위 고립성의 예시처럼 하나의 데이터에 두 트랜잭션이 접근하여 갱신하는 작업을 할 때 데이터가 손실되는 문제가 발생 가능.

하지만 데이터베이스의 빠른 응답처리를 위해서는 순서대로 실행할 수 없음

→ 이러한 문제때 사용하는 게 락

### 락(lock)

- 정의

갱신 손실 문제를 해결하기 위해 자신이 데이터를 수정중이라는 사실을 알리기 위한 잠금장치

- 과정

락을 통해 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 한다. 데이터 갱신을 순차적으로 진행할 수 있기에 갱신 손실 문제를 해결

ex) t1이 select 와 update문을 실행시킨 후 (갱신) 멈추고 t2를 실행 t2가 update를 실행하는 순간 락이 걸려있어서 대기. t1이 commit 실행하고 완료하면 락이 해제되고 그때 t2가 update문을 실행

- 락의 유형

공유락(shared lock , LS) : 트랜잭션이 읽기를 할 때 사용하는 락

배타락(exclusive lock , LX) : 읽기/ 쓰기를 할 때 사용하는 락

-> 다른 트랜잭션이 데이터에 LS를 걸어두면 LS 요청은 허용되고 LX는 허용 x
-> 다른 트랜잭션이 데이터에 LX를 걸어두면 LS,LX 모두 허용 X

허용받지 못하면 대기상태가 된다

### 2단계 락킹

락을 걸었다 풀고 다시 거는 중간 과정에 다른 트랜잭션에게 중간 결과가 보일 수 있음

ex) t1이 실행중에 데이터에 대한 락을 해제하고 t1이 작업 중인 중간 데이터를 가져와 t2가 작업을 하면 결과가 달라질 수 있음

→ 해결방법 : 2단계 락킹 기법

잠금을 두 단계로 나눠서 수행

- 확장단계(growing phase) : 트랜잭션에 필요한 락을 획득하는 단계로 이미 있는 락을 해제 X
- 수축단계(shrinking phase) : 트랜잭션에 락을 해제하는 단계로 새로운 락을 획득 X

ex) t1 , t2 모두 a, b 두 데이터를 다룸 , t1이 a데이터를 사용할 때 락을 걸고 a데이터를 사용하고 b데이터를 사용할 때도 a에 걸었던 락을 미리 해제하면 안됨 (확장단계) 그리고 b데이터까지 다 사용을 하고 락을 해지함( 수축단계)

### 데드락

2단계 락킹 기법을 사용하면 일관성을 유지할 수 있지만 데드락이 발생할 수 있음

데드락이란?

→ 둘 이상의 트랜잭션이 다른 트랜잭션이 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

ex) t1이 a 데이터 사용 후 락을 해지하지 않고 b 데이터를 사용하기 위해 대기 t2는 b 데이터를 사용하고 락을 해지하지 않고 a 데이터를 사용하기 위해 대기. 이처럼 해지되기를 서로 기다리면 무한대기에 빠질 수 있음

데드락 해결법

- 오라클의 경우 데드락 발생을 감지하면 한쪽 트랜잭션을 풀어버림
- 트랜잭션 처리 속도를 최소화한다.
  - update문이 빠르게 처리되면, 교착 상태가 발생할 가능성이 줄어든다.
- `set_lock_timeout` 문을 사용하여 잠금 해제 시간을 조절한다.
  - 잠금 시간을 설정하면 교착 상태가 발생했을 때 무기한 대기하지 않고 중간에 잠금이 풀리게 된다.
- innodb에서는 deadlock 현상이 발생하면 하나의 트랜잭션을 deadlock을 해결한 후 과정을 로그에 남긴다 - 로그는 show engine innodb status 명령어를 통해서 확인 가능
  <br></br>

# 트랜잭션 고립 수준

트랜잭션 동시 실행 문제 : 읽기만 하는 트랜잭션이 쓰기 트랜잭션에서 작업한 중간 데이터를 읽기 때문에 발생하는 문제들로 오손읽기, 반복 불가능한 읽기, 유령 데이터 읽기 존재
<br></br>

### 오손읽기 (dirty read)

아직 커밋되지 않은 데이터를 읽는 상황
<br></br>
ex) <br></br>![image](https://user-images.githubusercontent.com/81469686/213858440-db5cc377-af48-409b-834b-f1cc842b8b2b.png)

b의 select 쿼리 결과에서는 a가 삽입한 커밋되지 않은 새로운 사원이 조회 . 만약 이때 A가 삽입한 내용을 롤백해도 b는 jubal이 정상적인 사원이라 판단하고 계속해서 처리
<br></br>

### 반복 불가능한 읽기(non repeatable read)

트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복하지 않는 현상
<br></br>
ex) <br></br>
![image](https://user-images.githubusercontent.com/81469686/213858537-e0af684d-85a7-4595-a891-cb8efe9999fa.png)

b가 트랜잭션을 시작하고 name이 Toto인 사원을 조회하면 데이터가 존재하지 않음 하지만 a가 Jubal 이름을 Toto로 수정하고 커밋후 B가 똑같은 select 쿼리로 조회하면 아까와 다르게 1건의 결과가 조회됨 동일한 select 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 Repeatable Read에 어긋나게 됨<br></br>

### 유령 데이터 읽기(phantom read)

트랜잭션 1이 읽기 작업을 다시 한번 반복할 경우 이전에 없던 데이터가 나타나는 현상
<br></br>
ex)<br></br>
![image](https://user-images.githubusercontent.com/81469686/213858780-d8c4677d-97e7-4c2a-921e-e9075ca4ddc8.png)
<br></br>동일한 트랜잭션 내에서 동일한 쿼리는 항상 같은 결과를 출력해야하지만 이전에 없던 데이터가 나타나면서 다른 결과를 보여주고 있음
<br></br>
이런 문제들을 트랜잭션 고립 수준 명령어를 통해 제어할 수 있음

<br></br>

### Read uncommitted

고립수준이 가장 낮은 명령어로 커밋되지 않았어도 읽는게 가능함

→ 오손읽기, 반복 불가능한 읽기, 유령 데이터 읽기 다 발생가능
<br></br>

### Read committed

커밋 되어야만 다른 트랜잭션에서 조회할 수 있게하는 명령어이다

ex) 트랜잭션1이 10번 사원 나이 조회 , 27살 조회됨 트랜잭션2에서 27살에서 28살로 바꾸고 커밋 , 트랜잭션1이 10번 사원 나이 다시 조회하면 28살이 조회됨

→ 커밋된 데이터만 읽기에 오손읽기( 롤백으로 존재하지 않는 데이터를 읽기)와 같은 경우는 발생하지 않지만 반복불가능한 읽기와 유령데이터 읽기는 가능함
<br></br>

### Repeatable read

트랜잭션이 종료할때까지 공유락과 배타락을 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(update)할 수 없도록 한다

- InnoDB(스토리지엔진)의 경우

InnoDB(스토리지엔진)이 select 수행시 snapshot을 만든 후 snapshot으로 select를 수행하기에 commit 되더라도 새로 commit된 데이터는 보이지 않음 ( 결과를 동일하게 유지)

ex) 트랜잭션1이 10번 사원 나이를 조회 27살로 조회, 트랜잭션2가 10번 사원의 나이를 28살로 변경, 트랜잭션1이 10번 사원의 나이를 조회하면 snapshot을 읽어서 27살로 조회

→ 오손읽기와 반복불가능한 읽기 유령 데이터 읽기 방지

<aside>
💡 InnoDB(스토리지엔진)은 처음 데이터를 읽어올때 snapshot을 구축하여 자료를 가져옴

</aside>

스토리지 엔진(storage engine)은 데이터베이스 관리 시스템(DBMS)이 데이터베이스에 대해 데이터를 삽입, 추출, 업데이트 및 삭제(CRUD 참조)하는 데 사용하는 기본 소프트웨어 컴포넌트

- InnoDB(스토리지엔진)이 아닌 경우

t1이 읽고 있는 데이터에 락을 해지하지 않으면 t2가 데이터를 update하는 걸 막음 update문을 실행하려는 순간 대기 상태

→ 오손읽기와 반복불가능한 읽기는 방지가능하지만 유령데이터 읽기는 방지 불가능
<br></br>

### Serializable

고립 수준이 가장 높은 명령어로 실행중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리, 제한이 가장 심하고 동시성도 낮음

serializable 모드는 데이터 집합에 범위를 지어 잠금을 설정할 수 있기에 트랜잭션을 완벽하게 분리할 수 있음
serializable은 인덱스에 공유락을 설정하여 다른 트랜잭션의 insert 문이 금지되어 repeatable read에서 해결하지 못한 phantom read 문제를 해결할 수 있다

t1은 t2가 데이터를 삽입하는 것에 상관없이 새로 삽입한 데이터를 제외하고 읽음

→ 오손읽기, 반복불가능한 읽기, 유령 데이터읽기 방지 가능
<br></br>

|                  | 오손읽기 | 반복불가능한 읽기 | 유령데이터 읽기 |
| ---------------- | -------- | ----------------- | --------------- |
| READ UNCOMMITTED | 가능     | 가능              | 가능            |
| READ COMMITTED   | 불가능   | 가능              | 가능            |
| REPEATABLE READ  | 불가능   | 불가능            | 가능            |
| SERIALIZABLE     | 불가능   | 불가능            | 불가능          |

# 회복

### 트랜잭션과 회복

회복은 데이터베이스에 장애가 발생했을 때 일관성 있는 상태로 되돌리는 dbms 기능

트랜잭션은 데이터베이스 회복의 단위

- 시스템 충돌 등 데이터베이스 장애가 아니더라도 작업 중 문제가 생겨 롤백(데이터 변경 사항이 취소되어 데이터의 이전 상태로 복구)을 해야하는 경우 개발자가 의도로 회복을 할 수도 있다

### 로그 파일

dbms는 트랜잭션 수행 또는 수행 완료 후 발생하는 데이터베이스 손실을 막기 위해 데이터베이스 기록을 추적하는 로그 파일을 사용

그래서 이 변경 기록을 저장해 둔 로그 파일을 이용해 복구 가능

- 재실행(REDO)
  로그파일에 트랜잭션의 시작과 종료(commit)가 있는 경우 트랜잭션이 모두 완료되었다는 의미로 로그 파일에 있는 변경 사항을 데이터베이스에 다시 기록
- 취소(UNDO)
  트랜잭션의 시작만 있고 종료(commit)이 없는 경우 트랜잭션이 완료되지 못했다는 의미로 트랜잭션이 한 일을 모두 취소하고 로그 파일을 보면서 데이터베이스의 변경내용을 원상복구

ex) 10을 20으로 업데이트하고 20을 30으로 업데이트하는 트랜잭션이 있다고 가정. 10을 20으로 업데이트까지 했는데 장애로 회복해야 한다면 commit이 없기에 이 트랜잭션을 취소. 만약 트랜잭션이 완료해 commit이 있는데 회복해야 한다면 로그 레코드를 이용하여 데이터베이스 항목 값을 기록

- 즉시 갱신(immediate update)
  버퍼→ 로그파일 , 버퍼→ 데이터베이스 작업이 부분 완료 전에 동시에 진행하는 방법
- 지연 갱신(deferred update)
  버퍼→ 로그 파일이 끝나고 부분 완료후 버퍼→ 데이터베이스 작업을 진행하는 방법
  장애 발생할 경우 undo할 필요 없음

### 체크포인트

체크포인트 : 회복시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위해 데이터 베이스와 트랜잭션 로그 파일을 동기화 한 후 동기화 시점을 기록해두는데 그 시점

DBMS에서 회복을 할 때 처음부터 마지막 로그 기록까지 한번에 처리하려면 시간적으로 오래 걸릴 수 밖에 없기에 특정 시간 마다 검사를 하여 문제가 없음을 확인하면 다음번 에러 발생 시 회복을 시작하는 시점을 앞으로 당길 수 있기에 이렇게 회복이 오래 걸릴 트랜잭션에는 중간에 체크 포인트가 필요한 것 같습니다

- 체크포인트 이전에 commit 기록 있는 트랜잭션
  아무 작업 필요 없다
- 체크포인트 이후 commit 기록이 있는 트랜잭션
  REDO 진행
- 체크포인트 이후 commit 기록이 없는 트랜잭션
  즉시갱신 - > UNDO 진행 ( 데이터베이스에 반영되었을 수도 있기에)
  자연 갱신 → 아무 작업 필요없다

  ex)
  | 로그 번호 | 로그 레코드 |
  | --- | --- |
  | 1 | [T1 START] |
  | 2 | [T1 UPDATE B 200 120] |
  | 3 | [T2 START] |
  | 4 | [T2 UPDATE A 110 120] |
  | 5 | [T1, COMMIT] |
  | 7 | [T2 UPDATE B 120 220] |
  | 8 | [CHECKPONT] |
  | 9 | [T3 START] |
  | 10 | [T3 UPDATE A 110 120] |
  | 11 | [T2 UPDATE D 400 410] |
  | 12 | [T2 COMMIT] |
  | 13 | [T3 UPDATE B 220 230] |

이 과정을 거친 후 시스템 장애가 발생했다고 가정

즉시갱신기법을 사용하여 회복하면 checkpoint 전에 commit한 t1은 아무 작업이 필요 없고 t2는 redo , t3는 undo 작업이 필요

지연갱신 기법을 사용하여 회복한다면 t1,t3는 아무 작업 필요없고 t2는 redo가 필요
