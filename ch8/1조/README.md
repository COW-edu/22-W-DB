# [3주차]*8장*트랜잭션, 동시성 제어, 회복\_박가현

# 트랜잭션

### 정의

- 데이터베이스에서 상태를 변화시키는 작업 단위
- 한번에 수행되어야 할 일련의 연산
- ex) 회원의 등급 업그레이드
- 이런 트랜잭션은 사람의 기준에 따라 정해지는데 잘 설계하는 것이 데이터를 다룰 때 많은 이점을 가져옴

### 동작 과정

- 트랜잭션은 데이터베이스에 저장된 테이블을 읽어와 주기억장치 버퍼에 저장하고 버퍼에 저장된 데이터를 수정한 후 최종적으로 데이터베이스에 다시 저장
  - ex) a계좌에서 만원을 인출하여 b계좌에 만원을 입금하는 트랜잭션이 있다고 가정하면
  1. a계좌 값을 주기억장치버퍼로 읽어온다
  2. b계좌 값을 주기억장치버퍼로 읽어온다
  3. a계좌에서 만원을 인출한 값을 저장
  4. b계좌에서 만원을 입금한 값을 저장
  5. a계좌의 값을 데이터베이스에 기록한다
  6. b계좌의 값을 데이터베이스에 기록한다
  - 그런데 실제 dbms는 4번까지만 수행을 하고 commit을 통해 완료했다고 알림 이는 사용자에게 빠른 응답성과 다른 트랜잭션의 수행을 위해서 ( 나머지 5, 6은 dbms가 책임지고 수행)

### 트랜잭션 성질

- 원자성(atomicity)
  하나의 트랜잭션이 더 작게 나눌 수 없는 최소의 단위라는 뜻으로 트랜잭션 안에 있는 작업이 전부 수행되거나 전부 수행되지 않아야 함.
  ex) 위의 예시처럼 만원을 인출하였지만 만원을 입금하지 않고 부분적으로만 수행한다면 큰 문제가 생겨남 - rollback
  트랜잭션을 전체 혹은 savepoint까지 무효화시킴 - savepoint
  수정내용을 반영하는 포인트( 저장점)
- 일관성(consistency
  테이블이 생성될 때 create 문과 alter문의 무결성 제약조건을 통해 명시된다 ( ex) not null…) 트랜잭션은 이 조건에 따라 일관성을 유지
  ex) 모든 계좌의 돈은 0원 이상이어야 한다. 라는 무결성 제약 조건이 있다면 이를 위반하는 트랜잭션은 모두 중단
- 고립성(isolation)
  트랜잭션이 수행되고 있을 때, 다른 트랜잭션의 연산작업이 중간에 끼어들어 기존 작업에 영향을 주지 못하도록 하는 것.
  ex) 계좌 이체 작업을 진행하고 있는 도중 계좌 잔액을 조회하는 트랜잭션 같은 건 동시에 수행될 수 없다
  ex) 동시에 작업이 수행되는 것의 문제점은 한 트랜잭션은 잔액이 5만원인 계좌에서 만원을 빼 4만원을 만들어 저장하였는데 동시에 다른 트랜잭션이 5만원인 계좌에서 만원을 더해 6만원을 저장하였다. 옳지 않은 금액이 저장됨

- 지속성(durability)
  트랜잭션을 성공한 후 데이터베이스에 반영되는 것은 영원히 반영되어야 한다는 것을 의미. 시스템에 문제가 발생하거나 종료되더라도 데이터베이스에 반영된 값은 그대로 유지 필요

<aside>
💡 dbms는 트랜잭션이 안정적으로 처리될 수 있도록 원자성 일관성 고립성 지속성을 유지하도록 지원한다 ( 회복관리자 프로그램, 무결성 제약조건, 동시성 제어)

</aside>

# 동시성 제어

### 갱신 손실 문제

위 고립성의 예시처럼 하나의 데이터에 두 트랜잭션이 접근하여 갱신하는 작업을 할 때 데이터가 손실되는 문제가 발생 가능.

하지만 데이터베이스의 빠른 응답처리를 위해서는 순서대로 실행할 수 없음

→ 이러한 문제때 사용하는 게 락

### 락

- 정의

갱신 손실 문제를 해결하기 위해 자신이 데이터를 수정중이라는 사실을 알리기 위한 잠금장치

- 과정

락을 통해 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 한다. 데이터 갱신을 순차적으로 진행할 수 있기에 갱신 손실 문제를 해결

ex) t1이 select 와 update문을 실행시킨 후 (갱신) 멈추고 t2를 실행 t2가 update를 실행하는 순간 락이 걸려있어서 대기. t1이 commit 실행하고 완료하면 락이 해제되고 그때 t2가 update문을 실행

- 락의 유형

공유락 : 트랜잭션이 읽기를 할 때 사용하는 락

배타락 : 읽기/ 쓰기를 할 때 사용하는 락

### 2단계 락킹

락을 걸었다 풀고 다시 거는 중간 과정에 다른 트랜잭션에게 중간 결과가 보일 수 있음

ex) t1이 실행중에 데이터에 대한 락을 해제하고 t1이 작업 중인 중간 데이터를 가져와 t2가 작업을 하면 결과가 달라질 수 있음

→ 해결방법 : 2단계 락킹 기법

잠금을 두 단계로 나눠서 수행

- 확장단계 : 트랜잭션에 필요한 락을 획득하는 단계로 이미 있는 락을 해제 X
- 수축단계 : 트랜잭션에 락을 해제하는 단계로 새로운 락을 획득 X

ex) t1 , t2 모두 a, b 두 데이터를 다룸 , t1이 a데이터를 사용할 때 락을 걸고 a데이터를 사용하고 b데이터를 사용할 때도 a에 걸었던 락을 미리 해제하면 안됨 (확장단계) 그리고 b데이터까지 다 사용을 하고 락을 해지함( 수축단계)

### 데드락

2단계 락킹 기법을 사용하면 일관성을 유지할 수 있지만 데드락이 발생할 수 있음

데드락이란?

→ 둘 이상의 트랜잭션이 다른 트랜잭션이 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

ex) t1이 a 데이터 사용 후 락을 해지하지 않고 b 데이터를 사용하기 위해 대기 t2는 b 데이터를 사용하고 락을 해지하지 않고 a 데이터를 사용하기 위해 대기. 이처럼 해지되기를 서로 기다리면 무한대기에 빠질 수 있음

데드락 해결법

대기그래프, 오라클의 경우 데드락 발생을 감지하면 한쪽 트랜잭션을 풀어버림

# 트랜잭션 고립 수준

읽기 트랜잭션과 쓰기 트랜잭션이 동시에 접근할 때 갱신손실같은 심각한 문제가 발생하진 않는데 오손읽기 반복불가능 읽기 유령읽기등 문제가 발생할 수 있음

### 오손읽기 (dirty read)

아직 커밋되지 않은 데이터를 읽는 상황

ex) 트랜잭션1이 업데이트하고 커밋되지 않은 상태로 두고 트랜잭션2가 업데이트된 행을 읽었음 그러다가 트래잭선1이 변경사항을 롤백하면 트랜잭션2는 존재하지 않는 데이터를 읽은 것임

### 반복 불가능한 읽기(non repeatable read)

트랜잭션이 동일한 행을 두번 읽었는데 매번 다른 값을 얻을 때 발생

ex) 트랜잭션 t1이 데이터를 읽음 그때 트랜잭션 t2가 동일한 데이터를 업데이트하고 커밋 그러고 t1이 동일한 데이터를 다시 읽음 t2가 커밋을 한 데이터이기에 dirty read처럼 틀린 데이터를 읽은 건 아니지만 sql문이 다른 결과를 도출하기에 문제

### 유령 데이터 읽기(phantom read)

트랜잭션1이 데이터를 읽고 트랜잭션 2가 데이터를 삽입하고 트랜잭션1이 다시한번 데이터를 읽을 때 생기는 문제

non repeatable read랑 비슷해보이지만 없던 데이터가 삽입되는 것에서 다르게 구분한다

ex) t1이 40대 이상인 사원을 검색했음 t2가 40대이상인 새로운 사원을 삽입했음 t1이 40대 이상인 사원을 다시 읽고 커밋하면 틀린 데이터는 아니지만 마찬가지로 sql문이 다른 결과를 도출

이런 문제들을 트랜잭션 고립 수준 명령어를 통해 제어할 수 있음

### Read uncommitted

고립수준이 가장 낮은 명령어로 커밋되지 않았어도 읽는게 가능함

→ 오손읽기, 반복 불가능한 읽기, 유령 데이터 읽기 다 발생가능

### Read committed

커밋 되어야만 다른 트랜잭션에서 조회할 수 있게하는 명령어이다

ex) 트랜잭션1이 10번 사원 나이 조회 , 27살 조회됨 트랜잭션2에서 27살에서 28살로 바꾸고 커밋 , 트랜잭션1이 10번 사원 나이 다시 조회하면 28살이 조회됨

→ 커밋된 데이터만 읽기에 오손읽기( 롤백으로 존재하지 않는 데이터를 읽기)와 같은 경우는 발생하지 않지만 반복불가능한 읽기와 유령데이터 읽기는 가능함

### Repeatable read

트랜잭션이 종료할때까지 공유락과 배타락을 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(update)할 수 없도록 한다

- mysql의 경우

mysql이 select 수행시 snapshot을 만든 후 snapshot으로 select를 수행하기에 commit 되더라도 새로 commit된 데이터는 보이지 않음 ( 결과를 동일하게 유지)

ex) 트랜잭션1이 10번 사원 나이를 조회 27살로 조회, 트랜잭션2가 10번 사원의 나이를 28살로 변경, 트랜잭션1이 10번 사원의 나이를 조회하면 snapshot을 읽어서 27살로 조회

→ 오손읽기와 반복불가능한 읽기 유령 데이터 읽기 방지

<aside>
💡 mysql은 처음 데이터를 읽어올때 snapshot을 구축하여 자료를 가져옴

</aside>

- mysql이 아닌 경우

t1이 읽고 잇는 데이터에 락을 해지하지 않으면 t2가 데이터를 update하는 걸 막음 update문을 실행하려는 순간 대기 상태

→ 오손읽기와 반복불가능한 읽기는 방지가능하지만 유령데이터 읽기는 방지 불가능

### Serializable

고립 수준이 가장 높은 명령어로 실행중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리, 제한이 가장 심하고 동시성도 낮음

t1은 t2가 데이터를 삽입하는 것에 상관없이 새로 삽입한 데이터를 제외하고 읽음

→ 오손읽기, 반복불가능한 읽기, 유령 데이터읽기 방지 가능

# 회복

### 트랜잭션과 회복

회복은 데이터베이스에 장애가 발생했을 때 일관성 있는 상태로 되돌리는 dbms 기능

트랜잭션은 데이터베이스 회복의 단위

### 로그 파일

dbms는 트랜잭션 수행 또는 수행 완료 후 발생하는 데이터베이스 손실을 막기 위해 데이터베이스 기록을 추적하는 로그 파일을 사용

그래서 이 변경 기록을 저장해 둔 로그 파일을 이용해 복구 가능

- 재실행(REDO)
  로그파일에 트랜잭션의 시작과 종료(commit)가 있는 경우 트랜잭션이 모두 완료되었다는 의미로 로그 파일에 있는 변경 사항을 데이터베이스에 다시 기록
- 취소(UNDO)
  트랜잭션의 시작만 있고 종료(commit)이 없는 경우 트랜잭션이 완료되지 못했다는 의미로 트랜잭션이 한 일을 모두 취소하고 로그 파일을 보면서 데이터베이스의 변경내용을 원상복구

ex) 10을 20으로 업데이트하고 20을 30으로 업데이트하는 트랜잭션이 있다고 가정. 10을 20으로 업데이트까지 했는데 장애로 회복해야 한다면 commit이 없기에 이 트랜잭션을 취소. 만약 트랜잭션이 완료해 commit이 있는데 회복해야 한다면 로그 레코드를 이용하여 데이터베이스 항목 값을 기록

- 즉시 갱신
  버퍼→ 로그파일 , 버퍼→ 데이터베이스 작업이 부분 완료 전에 동시에 진행하는 방법
- 지연 갱신
  버퍼→ 로그 파일이 끝나고 부분 완료후 버퍼→ 데이터베이스 작업을 진행하는 방법
  장애 발생할 경우 undo할 필요 없음

### 체크포인트

체크포인트 : 회복시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위해 데이터 베이스와 트랜잭션 로그 파일을 동기화 한 후 동기화 시점을 기록해두는데 그 시점

- 체크포인트 이전에 commit 기록 있는 트랜잭션
  아무 작업 필요 없다
- 체크포인트 이후 commit 기록이 있는 트랜잭션
  REDO 진행
- 체크포인트 이후 commit 기록이 없는 트랜잭션
  즉시갱신 - > UNDO 진행 ( 데이터베이스에 반영되었을 수도 있기에)
  자연 갱신 → 아무 작업 필요없다
