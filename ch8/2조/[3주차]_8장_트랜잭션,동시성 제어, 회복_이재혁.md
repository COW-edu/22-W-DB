# [3주차]_8장_트랜잭션,동시성 제어, 회복

## 트랜잭션

트랜잭션은 DBMS가 데이터베이스를 다룰 때 사용하는 작업 단위이다.

- 트랜잭션의 개념
    - 트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 된다.
    - 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 이 작업을 서로 분리하는 단위가 된다.
    - 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다.(All or Nothing)
- 수행 과정
    - 우리가 데이터베이스에 삽입, 수정, 삭제 등의 작업을 할 때, 여러 개의 작업들을 하나의 트랜잭션으로 묶는다. 예를 들어 A계좌에서 B계좌로 돈을 이체하는 경우 A에서 돈을 빼고 B에 돈을 더하는 2가지의 Update문으로 나뉘게 됩니다. 이것들이 개별적으로 수행되는 것이 아니라 하나의 트랜잭션으로 묶여 하나의 트랜잭션이 실행될 때 이 2개의 SQL문이 연속적으로 실행된다.
        1. A계좌의 값을 데이터베이스에서 주기억장치 버퍼로 읽어온다
        2. B계좌의 값을 데이터베이스에서 주기억장치 버퍼로 읽어온다
        3. A 계좌에서 인출한 값을 저장
        4. B 계좌에 입금한 값을 저장
        5. A 계좌의 값을 주기억장치 버퍼에서 데이터베이스에 기록
        6. B 계좌의 값을 주기억장치 버퍼에서 데이터베이스에 기록
    - Commit이란 트랜잭션의 수행이 완료됨을 트랜잭션 관리자에게 알려 주는 연산이다
    - DBMS는 사용자에게 빠른 응답을 위해 4번 과정 후 Commit을 하고 5, 6 을 수행하는 방법을 선택한다
- 트랜잭션의 ACID 성질
    - 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다
    - 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지하여야 한다
    - 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다
    - 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

## 동시성 제어

- 갱신손실(Lost Update)
    - 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화 되는 것
    - 두 개의 트랜잭션이 한 개의 데이터를 동시에 Update할 때 발생
    - 데이터베이스에서 절대 발생하면 안되는 현상
- 락(Lock)
    - Locking 기법: 트랜잭션들이 동일한 데이터 항목에 대해 임의적인 병행 접근을 하지 못하도록 제어하는 것
    - 트랜잭션 T가 데이터 항목 X에 대해 Read 또는 Write 연산을 수행하려면 반드시 lock 연산을 해야한다
    - 트랜잭션 T가 실행한 lock에 대해서는 해당 트랜잭션이 종료되기 전에 반드시 unlock연산을 해주어야 한다
    - 트랜잭션 T는 다른 트랜잭션에 의해 이미 lock이 걸려 있는 X에 대해 다시 lock을 수행시키지 못한다
    - 트랜잭션 T가 데이터에 lock을 걸지 않았다면, unlock 연산 수행시키지 못한다
    - 락의 종류
        - 공유락(Shared Lock): 읽기를 할 때 사용한다
        - 배타락(Exclusive Lock): 읽고 쓰기를 할 때 사용한다
    
    즉, 여러개의 트랜잭션이 하나의 데이터로 동시접근 하는 것을 제어하는 도구가 lock
    
- 2단계 락킹(Two-Phase Locking Protocol)
    - 트랜잭션들이 lock하는 시간과 unlock을 하는 시간을 구분하여 수행하도록 한다
        - 2단계 락킹을 사용하지 않으면 일관성이 위배되는 문제가 발생할 수 있다
        - 직렬 가능성을 보장할 수 있는 규약으로 가장 많이 사용되지만 교착상태가 발생할 가능성이 있지만 교착상태(데드락, Deadlock)에 빠질 수 있으므로 이를 해결해주어야 한다
- 데드락(Deadlock)
    - 데드락은 교착상태라고도 한다
    - 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상
    - 일반적으로 데드락이 발생하면 DBMS가 T1 혹은 T2 중 하나를 강제로 중지시켜 한 트랜잭션은 정상적으로 실행되며 중지된 트랜잭션에서 변경한 데이터는 원래 상태로 되돌려 놓는다
- 트랜잭션 고립수준
    
    트랜잭션들끼리 일관성 있는 데이터를 얼마나 허용할 것인지 정해놓은 수준이다
    
    - 이상현상의 종류
        - 오손읽기(Dirty Read): 어떤 트랜잭션에서 아직 실행이 끝나지 않은 트랜잭션에 의한 변경사항을 보게 되는 경우
        - 반복불가능 읽기(Non-repeatable Read): 어떤 트랜잭션이 같은 쿼리 2번을 실행하는데 그 사이 다른 트랜잭션이 수정/삭제하여 같은 쿼리에 다른 값이 나오는 경우
        - 유령데이터 읽기(Phantom Read): 트랜잭션이 같은 쿼리 2번 실행을 하는데 없던 레코드가 추가되어 같은 쿼리에 다른 값이 나오는 경우
- READ UNCOMMITTED
    - 고립 수준이 Lv.0으로 가장 낮다, 자신의 데이터에 아무런 공유락을 걸지 않는다
    - SELECT 문을 수행하는 경우 해당 데이터에 Shared Lock이 걸리지 않는 Level이다. 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 B라는 아직 완료되지 않은 데이터(오손 데이터) B를 읽을 수 있다.
- READ COMMITTED
    - 고립 수준이 Level 1인 명령어로, 오손 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지 가능하다.
    - SQL Server가 Default로 사용하는 Isolation Level으로 SELECT 문이 수행되는 동안에 Shared Lock이 걸린다. 그러므로 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안에 다른 사용자는 해당 데이터에 접근할 수 없다.
- Repeatable Read
    - 고립 수준이 Level 2인 명령어로, 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료될 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(Update)할 수 없도록 한다.
    - 트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 Shared Lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.
- Serializable
    - 고립 수준이 Level 3으로 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.
    - SELECT 문이 사용하는 모든 데이터에 Shared Lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정(UPDATE) 및 입력(INSERT)가 불가능하다.

## 회복

- 장애의 유형
    - 트랜잭션 장애: 트랜잭션의 논리적인 오류로 발생
    - 시스템 장애: HW 시스템 자체에 발생
    - 미디어 장애: 디스크 자체 손상으로 발생
- 트랜잭션과 회복
    - 데이터베이스를 갱신하는 과정에서 장애가 발생한 경우 회복절차를 수행하여 장애 발생 이전의 데이터베이스로 만드는 것이 회복이다
    - 회복을 위한 데이터 복사본을 만드는 방법은 2가지이다
        - 덤프(Dump): 가장 기본적인 방법으로 일정 주기로 원본의 데이터베이스의 모든 내용을 다른 저장장치에 복사한다
        - 로그(Log): 변경 이전의 데이터베이스를 기준으로 변경 연산이 발생할 때 마다 기록을 해두고 회복시에 활용하는 방법
- 로그 파일
    - 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스
    - 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 존재
    - 로그의 구조: <트랜잭션 번호, 로그의 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>
    - 로그의 타입: START, INSERT, UPDATE, DELETE, ABORT, COMMIT 등 트랜잭션의 연산 타입
- 체크포인트
    - DBMS에서 회복을 할 때 처음부터 마지막 로그 기록까지 한번에 처리하려면 시간적으로 오래 걸릴 수 밖에 없다. 그러므로 특정 시간 마다 검사를 하여 문제가 없음을 확인하면 다음번 에러 발생 시 회복을 시작하는 시점을 앞으로 당길 수 있다. 그래서 체크 포인트 시점에는 다음과 같은 작업을 수행하게 된다. 먼저 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장한다. 그리고 트랜잭션 수행 중에 변경된 버퍼 내의 내용을 하드디스크의 데이터베이스에 저장한다. 그리고 나서 체크포인트를 로그 파일에 다음과 같이 표시한다. <Checkpoint 현재 수행중인 트랜잭션 리스트>