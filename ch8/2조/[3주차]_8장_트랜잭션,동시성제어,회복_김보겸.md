# 8. 트랜잭션, 동시성 제어, 회복

## 1. 트랜잭션

- **트랜잭션의 개념**
  DBMS에서 데이터를 다루는 논리적인 작업의 단위, 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 함, 완료 후에는 다른 트랜잭션이 데이터를 자유롭게 사용할 수 있음
- **트랜잭션의 성질**

  1. 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 함

     ㄴ 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 함

  2. 일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
  3. 고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함

     ㄴ 동시에 수행되는 트랜잭션이 같은 데이터를 가지고 충돌하지 않도록 제어 하는 작업이 필요 = 동시성 제어

  4. 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함

- **트랜잭션과 DBMS**  
  DBMS는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원함, 원자성을 유지하기 위해 회복(복구) 관리자 프로그램을 작동, 일관성을 유지하기 위해 무결성 제약조건, 동시성 제어 알고리즘을 활용, 고립성을 유지하기 위해 동시성 제어 알고리즘을 작동, 지속성을 유지하기 위해 회복 관리자 프로그램을 이용

## 2. 동시성 제어

트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

- **트랜잭션의 읽기/쓰기 시나리오**  
  읽기 + 읽기 = 허용(문제 없음)  
  읽기 + 쓰기 = 허용 혹은 불가 선택(오손 읽기, 반복불가능 읽기, 유령 데이터 읽기)  
  쓰기 + 쓰기 = 허용 불가(갱신 손실)
- **갱신손실 문제**  
  두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생, 갱신손실 문제를 해결하려면 T1→T2 혹은 T2→T1 식으로 순서대로 실행하면 되지만 데이터베이스의 공유와 빠른 응답 처리를 위해 그럴 수 없음
- **락**  
  락은 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치  
  락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 함
  - 락의 유형
    - 공유락(LS): 트랜잭션이 읽기를 할 때 사용하는 락
    - 배타락(LX): 읽기/쓰기를 할 때 사용하는 락
      트랜잭션의 공유락은 상호 허용이 되지만 배타락은 허용되지 않음
  - 2단계 락킹  
    데이터에 락을 걸었다 풀고 다시 거는 중간 과정에 락의 해지 상태가 생기면서 다른 트랜잭션에게 중간 결과를 보일 수 있음, 이것을 방지하기 위하여 2단계 락킹을 사용
    - 확장 단계: 트랜잭션이 필요한 락을 획득하는 단계로, 이 단계 에서는 이미 획득한 락을 해제하지 않음
    - 수축 단계: 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않음
  - 데드락  
    두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있음, 이러한 현상을 데드락 혹은 교착상태라고 함, 일반적으로 데드락이 발생하면 DBMS는 T1 혹은 T2의 작업 중 하나를 강제로 중지시킴, 이 때 중지시키는 트랜잭션에서 변경한 데이터는 원래 상태로 되돌려 놓음

## 3. 트랜잭션 고립 수준

- **트랜잭션 동시 실행 문제**
  - 오손 읽기  
    읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제, 작업 중인 트랜잭션 2가 어떤 이유로 작업을 철회할 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출
  - 반복불가능 읽기  
    트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 갱신하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
  - 유령데이터 읽기  
    트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 삽입하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제, 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상
- **트랜잭션 고립 수준 명령어**  
  DBMS는 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하는 명령어를 제공
  - READ UNCOMMITTED(Level=0)  
    고립 수준이 가장 낮은 명령어, 자신의 데이터에 아무런 공유락을 걸지 않음, 또한 다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽음, 다른 트랜잭션이 COMMIT하지 않은 데이터도 읽을 수 있음
  - READ COMMITTED(Level=1)  
    오손 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지가능
  - REPEATABLE READ(Level=2)  
    자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신할 수 없도록 함, 데이터의 동시성이 낮아 특별한 상황이 아니라면 사용하지 않는 것이 좋음
  - SERIALIZABLE(Level=3)  
    고립 수준이 가장 높은 명령어, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리
- **유령데이터 읽기 문제와 방지를 위한 명령어**  
  MySQL은 T1의 최초 트랜잭션 SELECT 수행 시 SNAPSHOT을 만든 후 그 트랜잭션이 COMMIT되기 전까지 최초 SNAPSHOT으로 SELECT를 수행하여 다른 트랜잭션 T2 자료의 입력이나 변경 시에도 T1의 결과를 동일하게 유지하여 유령데이터 읽기가 발생하지 않음, 유령데이터 읽기 문제를 방지하려면 트랜잭션 T1의 고립 수준을 SERIALIZABLE 모드로 상향

## 4. 회복

데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능

- **장애의 유형**
  - 시스템 충돌
  - 미디어 장애
  - 응용 소프트웨어 오류
  - 자연재해
  - 부주의 혹은 태업
- **트랜잭션과 회복**  
  트랜잭션은 데이터베이스 회복의 단위, 트랜잭션은 데이터의 변경 내용을 한순간에 모두 기록하지 않음, 변경한 내용(버퍼)을 로그(임시 디스크)에 기록한 후 데이터베이스에 반영
- **로그 파일**  
  DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 데이터베이스 기록을 추적하는 로그 파일을 사용, 로그 파일은 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스, 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 남아있음
- **로그 파일을 이용한 회복**  
  로그 파일을 이용하면 시스템 장애도 복구할 수 있음
  - 트랜잭션의 재실행(REDO)  
    로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록함
  - 트랜잭션의 취소(UNDO)  
    완료하지 못했지만 버퍼의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시킴
  - 즉시갱신
  - 지연갱신
- **체크포인트를 이용한 회복**  
  몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법혹은 그 시점을 체크포인트라고 함
  1. 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장한다.
  2. 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장한다(즉시갱신 경우).
  3. 체크포인트를 로그 파일에 표시한다.
  - 체크포인트 이전에 COMMIT 기록이 있는 트랜잭션의 경우  
    아무 작업이 필요 없음
  - 체크포인트 이후에 COMMIT 기록이 있는 트랜잭션의 경우  
    REDO(T) 진행
  - 체크포인트 이후에 COMMIT 기록이 없는 트랜잭션의 경우  
    즉시갱신 방법을 사용했다면 UNDO(T) 진행, 지연갱신 방법을 사용했다면 아무것도 할 필요 없음
