# chapter 8 - 트랜잭션, 동시성 제어, 회복

## 트랜잭션

- **트랜잭션**: DBMS가 DB를 다룰 때 사용하는 작업(프로그램) 단위
    - DB의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 가짐
    - DBMS는 트랜잭션이 이러한 성질을 유지할 수 있도록 지원함
    - DB 회복의 단계임
    
- DB에서 트랜잭션을 정의하는 이유
    - 장애 시 데이터를 복구하는 작업의 단위가 됨
    - 여러 작업이 동시에 같은 데이터를 다룰 때, 트랜잭션이 이 작업을 서로 분리하는 단위가 됨
    
- 트랜잭션은 **전체가 수행되거나 또는 전혀 수행되지 않아야 함**
    
    Ex) a 계좌에서 b 계좌로 10,000원을 이체할 경우
    
    1. a 계좌에서 10,000원을 인출하는 SQL UPDATE 문
    2. b 계좌에 10,000원을 입금하는 SQL UPDATE 문
    
    ⇒ 1번 SQL이 수행된 후 시스템에 문제가 생기거나 다른 UPDATE문이 끼어들면 계좌의 잔액이 의도하지 않은 값이 될 수 있음 따라서 1,2번 SQL은 모두 수행되거나 아예 수행되지 않아야 함
    
    1번과 2번이 하나의 수행 단위라는 것을 알리기 위해 **START TRANSACTION** 문과 **COMMIT** 문을 사용해 트랜잭션의 시작과 끝을 표시함
    
- **트랜잭션의 수행 과정**
    - 시작 → 수행 → 부분완료 → 버퍼내용 기록 → 완료

- **트랜잭션의 성질 (ACID 성질)**
    - **원자성(Atomicity)**: 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 함
        - 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 함
        - 트랜잭션 제어 명령어
            - **COMMIT, ROLLBACK**
        - 트랜잭션의 중간 지점에 수정내용을 반영하는 포인트 ⇒ **SAVEPOINT**
        
    - **일관성(Consistency)**: 트랜잭션을 수행하기 전이나 수행한 후나 DB는 항상 일관된 상태를 유지해야 함
        - 테이블이 생성될 때 CREATE문과 ALTER문의 무결성 제약조건을 통해 명시됨
        
    - **고립성(Isolation)**: 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
        - 고립성을 유지하기 위해서 변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할 때 제어하는 작업이 필요함 ⇒ **동시성 제어**
        
    - **지속성(Durability)**: 저장된 DB는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 함
        - **부분완료**: 트랜잭션 수행은 완료되었지만 변경 내용이 DB에 기록되었는지 확실하지 않은 상태
        - **실패**: 트랜잭션을 중간에 중단했거나 부분완료 상태에서 변경 내용을 DB에 저장하지 못한 상태

## 동시성 제어

: 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

- 트랜잭션1, 트랜잭션2 둘 다 쓰기 작업을 하는 경우
    
    ⇒ **갱신손실 문제**가 발생할 수 있음
    
    - 갱신손실 문제: 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생
        - 해결법 ⇒ **락**
        
    - **락**: 자신이 사용할 데이터를 잠그면 다른 트랙잭션은 잠금이 풀릴 때까지 기다려야 함
        - 데이터에 대한 갱신을 순차적으로 진행할 수 있기 때문에 갱신손실 문제를 해결할 수 있음
        - 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨지는 것을 방지하기 위해 **2단계 락킹 기법**을 사용
    
    - **2단계 락킹 기법**
        - 트랜잭션이 락을 걸고 해제하는 시점을 2단계로 나누어 진행
            - **확장단계**: 트랜잭션이 필요한 락을 획득하는 단계로, 이미 획득한 락을 해제하지 않음
            - **수축단계**: 트랜잭션이 락을 해제하는 단계로, 새로운 락을 획득하지 않음
            

## 트랜잭션 고립 수준

- 두 트랜잭션이 (읽기, 쓰기)인 상황인 경우
    - **오손 읽기**: 읽기 작업을 하는 트랜잭션1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 생기는 문제
        - 작업 중인 트랜잭션2가 ROLLBACK할 경우 트랜잭션1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출함
    - **반복불가능 읽기**: 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고, 트랜잭션1이 다시 한 번 데이터를 읽을 때 생기는 문제
        - 트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복되지 않는 현상
    - **유령데이터 읽기**: 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고, 트랜잭션1이 다시 한 번 데이터를 읽을 때 생기는 문제
        - 트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없는 데이터(유령 데이터)가 나타나는 현상

- **트랜잭션 고립 수준 명령어**: DBMS가 제공하는 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하는 명령어
    - READ UNCOMMITTED
    - READ COMMITTED
    - REPEATABLE READ
    - SERIALIZABLE

## 회복

: DB에 장애가 발생했을 때 DB를 일관성 있는 상태로 되돌리는 DBMS의 기능

- DB 시스템에서 발생할 수 있는 장애의 유형
    - 시스템 충돌
    - 미디어 장애
    - 응용 소프트웨어 오류
    - 자연재해
    - 부주의 혹은 태업

- **트랜잭션과 회복**

- **로그 파일**
    - DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 DB 손실을 방지하기 위해 트랜잭션의 DB 기록을 추적하는 로그 파일을 사용함
    - 트랜잭션이 반영한 모든 데이터의 변경사항을 DB에 기록하기 전에 미리 기록해두는 **별도의 DB임**
    - 시스템에 장애가 일어났을 때 어느 시점까지 되돌아가야 하는지 알 수 없음

- **체크포인트를 이용한 회복**
    - **체크포인트**: 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위해 몇 십 분 단위로 DB와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법 혹은 그 시점

---

## 저번주차 피드백 관련 추가 내용

- nomalization의 문제점: 데이터 조회 시 join을 유발해 성능 저하가 발생할 수도 있음
⇒ 해결방법: **denomalization (반정규화)**

- **반정규화**: 정규화된 entity, attribute, relation에 대해 중복, 통합, 분리 등을 수행하는 것
    - 시스템의 성능 향상, 개발과 운영의 단순화를 위해
    - 절차
        - **반정규화 대상 조사 → 다른 방법 유도 검토 → 반정규화 적용**
    - 방법
        - **table**
            - 병합
            - 분할 (수평/수직)
            - 추가
        - **column**
            - 중복 column 추가
            - pk에 의한 column 추가
        - **relation**
            - 조회(select) relation을 단순화시키기 위해 relation을 중복